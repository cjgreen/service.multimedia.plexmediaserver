RE_EPISODE = Regex('\d+$')

####################################################################################################
def NormalizeURL(url):

	return url.split('?')[0]

####################################################################################################
def MetadataObjectForURL(url):

	try:
		page = HTML.ElementFromURL(url, cacheTime=CACHE_1DAY)
	except:
		raise Ex.MediaNotAvailable

	show = page.xpath('//meta[@property="og:title"]/@content')[0].split(' | ')[0].rsplit(' ',1)[0]
	absolute_index = int( page.xpath('//meta[@property="og:title"]/@content')[0].split(' | ')[0].rsplit(' ',1)[1] )

	try:
		title = page.xpath('//h3[@class="field-content"]/text()')[0].strip()
	except:
		title = '%s %d' % (show, absolute_index)

	summary = page.xpath('//meta[@property="og:description"]/@content')[0]

	try:
		originally_available_at = page.xpath('//div[@class="views-field views-field-created"]/*/text()')[0]
		originally_available_at = Datetime.ParseDate(originally_available_at).date()
	except:
		originally_available_at = None

	thumbs = []

	poster = page.xpath('//video[@poster]/@poster')
	if len(poster) > 0:
		thumbs.append(poster[0])

	image = page.xpath('//meta[@property="og:image" and @content]/@content')
	if len(image) > 0:
		thumbs.append(image[0])

	return EpisodeObject(
		show = show,
		title = title,
		absolute_index = absolute_index,
		summary = summary,
		originally_available_at = originally_available_at,
		thumb = Resource.ContentsOfURLWithFallback(url=thumbs)
	)

####################################################################################################
def MediaObjectsForURL(url):

	return [
		MediaObject(
			parts = [PartObject(key=Callback(PlayMedia, url=url, fmt='720p'))],
			video_resolution = '720',
			#aspect_ratio = '1.78',
			container = Container.MP4,
			video_codec = VideoCodec.H264,
			audio_codec = AudioCodec.AAC,
			audio_channels = 2,
			optimized_for_streaming = True
		),
		MediaObject(
			parts = [PartObject(key=Callback(PlayMedia, url=url, fmt='480p'))],
			video_resolution = '480',
			#aspect_ratio = '1.78',
			container = Container.MP4,
			video_codec = VideoCodec.H264,
			audio_codec = AudioCodec.AAC,
			audio_channels = 2,
			optimized_for_streaming = True
		),
		MediaObject(
			parts = [PartObject(key=Callback(PlayMedia, url=url, fmt='sd'))],
			video_resolution = 'sd',
			#aspect_ratio = '1.78',
			container = Container.MP4,
			video_codec = VideoCodec.H264,
			audio_codec = AudioCodec.AAC,
			audio_channels = 2,
			optimized_for_streaming = True
		)
	]

####################################################################################################
@indirect
def PlayMedia(url, fmt):

	page = HTML.ElementFromURL(url, cacheTime=CACHE_1DAY)

	resolutions = ['720p','480p','sd']
	video_path = {
		'720p' : '//a[@class="hd download"]/@href',
		'480p' : '//a[@class="sd download"]/@href',
		'sd'   : '//a[@class="sd-low download"]/@href'
	}

	index = resolutions.index(fmt)

	for resolution_index in range(index, len(resolutions)):
		current_resolution = resolutions[resolution_index]
		try:
			url = page.xpath(video_path[current_resolution])[0]
			break
		except:
			# if this didn't work fall back to next resolution
			continue

	# TODO:  Raise a new exception if we don't get a viable url (not sure how to do that just yet)

	if 'twit.mediafly.com' in url:
		url = url.replace('twit.mediafly.com', 'twit.cachefly.net')

	url = url.strip()

	if ' ' in url:
		url = url.split(' ')[0]

	return IndirectResponse(VideoClipObject, key=url)

####################################################################################################
def TestURLs():

	test_urls = []

	for url in XML.ElementFromURL('http://twit.tv/node/feed').xpath('//item/link/text()'):
		if len(test_urls) < 3:
			if url not in test_urls and RE_EPISODE.search(url):
				test_urls.append(url)
		else:
			break

	return test_urls
